var documenterSearchIndex = {"docs":
[{"location":"modulo/#Modular-numbers","page":"Modular numbers","title":"Modular numbers","text":"","category":"section"},{"location":"modulo/#FiniteFields.Modulo","page":"Modular numbers","title":"FiniteFields.Modulo","text":"This module introduces modular arithmetic. It has no dependencies.\n\nThe  integer x mod. n is constructed  by the function Mod(x,n). If n isa  Int the result is of type Mod{UInt64}. If n isa BigInt the result is  of  type  Mod{BigInt}.  Since  n  is  not  encoded in the type, the elements  0 and 1 mod.  n cannot be constructed  from the type, which causes  some problems for some Julia functionality (for instance inv on a matrix  does  not  work).  For  prime  moduli  p,  the  type  FFE{p} in FiniteFields does not have such limitations.\n\nExample:\n\njulia> a=Mod(3,20)\nMod{UInt64}: 3â‚‚â‚€\n\njulia> a^2\nMod{UInt64}: 9â‚‚â‚€\n\njulia> inv(a) # need to be invertible mod. 20\nMod{UInt64}: 7â‚‚â‚€\n\njulia> a*inv(a)\nMod{UInt64}: 1â‚‚â‚€\n\njulia> a+2\nMod{UInt64}: 5â‚‚â‚€\n\njulia> a*2\nMod{UInt64}: 6â‚‚â‚€\n\njulia> a+1//3 # the denominator of the fraction needs to be inveritble mod. 20\nMod{UInt64}: 10â‚‚â‚€\n\njulia> Integer(a) # get back an integer from a\n3\n\njulia> order(a) # multiplicative order of a\n4\n\njulia> a^4\nMod{UInt64}: 1â‚‚â‚€\n\n\n\n\n\n","category":"module"},{"location":"finitefields/#Finite-fields","page":"Finite fields","title":"Finite fields","text":"","category":"section"},{"location":"finitefields/#FiniteFields","page":"Finite fields","title":"FiniteFields","text":"This   package  introduces  finite  fields   using  the  GAP  syntax.  This compatibility   with  GAP  is  the  motivation  not  to  use  the  existing GaloisFields.  The  speed  is  comparable  with  GaloisFields, slightly slower for prime fields and faster for composite fields. Like GAP3, we only implement fields of order less than 2^16.\n\nThe only dependency of this package is the package Primes.\n\nThe  Galois field with  p^n elements is  obtained as GF(p^n). All elements of Galois fields of characteristic p have the same type, the parametric type FFE{p}. The function Z(p^n) returns a  generator of  the multiplicative  group of  GF(p^n). Other elements of GF(p^n)  are  obtained  as  powers  of  Z(p^n), except 0, obtained as 0*Z(p^n). Elements of the prime field can also be obtained as FFE{p}(n) (which is the same as n*Z(p)^0).\n\njulia> a=Z(64)\nFFE{2}: Zâ‚†â‚„\n\njulia> a^9 # automatic conversion to smaller fields\nFFE{2}: Zâ‚ˆ\n\njulia> a^21\nFFE{2}: Zâ‚„\n\njulia> a+1\nFFE{2}: Zâ‚†â‚„âµâ¶\n\nElements  of the prime field can be converted to Mod(,p) or to integers:\n\njulia> a=Z(19)+3\nFFE{19}: 5\n\njulia> Mod(a)\nMod{UInt64}: 5â‚â‚‰\n\njulia> Int(a)\n5\n\njulia> order(a) # order as element of the multiplicative group\n9\n\nThe field, p, n and p^n can be obtained back from an FFE{p} as well as which power of Z(p^n) is considered\n\njulia> a=Z(8)^5\nFFE{2}: Zâ‚ˆâµ\n\njulia> F=field(a)\nGF(2^3)\n\njulia> char(F) # the characteristic p\n2\n\njulia> char(a)\n2\n\njulia> degree(F) # the n in p^n\n3\n\njulia> degree(a)\n3\n\njulia> length(F) # p^n\n8\n\njulia> log(a) # such that a==Z(p^n)^log(a)\n5\n\njulia> elements(F)\n8-element Vector{FFE{2}}:\n   0\n   1\n  Zâ‚ˆ\n Zâ‚ˆÂ²\n Zâ‚ˆÂ³\n Zâ‚ˆâ´\n Zâ‚ˆâµ\n Zâ‚ˆâ¶\n\nA  p-integral rational number or a  Mod(,p) can be  converted to a prime field element using FFE{p} as a constructor.\n\njulia> FFE{19}(2)\nFFE{19}: 2\n\njulia> FFE{19}(5//3)\nFFE{19}: 8\n\njulia> FFE{19}(Mod(2,19))\nFFE{19}: 2\n\njulia> m=rand(GF(49),4,4)\n4Ã—4 Matrix{FFE{7}}:\n Zâ‚„â‚‰Â²â´  Zâ‚„â‚‰Â¹â¸   Zâ‚„â‚‰â¹  Zâ‚„â‚‰â´Â²\n Zâ‚„â‚‰Â²Â²  Zâ‚„â‚‰â´Â¹  Zâ‚„â‚‰â´â¶  Zâ‚„â‚‰Â²â´\n Zâ‚„â‚‰Â¹âµ  Zâ‚„â‚‰Â¹â¹  Zâ‚„â‚‰â´â°   Zâ‚„â‚‰Â³\n Zâ‚„â‚‰Â²â°  Zâ‚„â‚‰Â²â¹  Zâ‚„â‚‰Â³â¶  Zâ‚„â‚‰Â²â°\n\njulia> inv(m)\n4Ã—4 Matrix{FFE{7}}:\n Zâ‚„â‚‰Â³â·   Zâ‚„â‚‰âµ  Zâ‚„â‚‰Â³â¶      1\n Zâ‚„â‚‰Â¹â°    Zâ‚„â‚‰   Zâ‚„â‚‰â¶  Zâ‚„â‚‰â´â·\n Zâ‚„â‚‰Â³â°  Zâ‚„â‚‰Â³â¸    Zâ‚„â‚‰     -2\n Zâ‚„â‚‰Â¹âµ   Zâ‚„â‚‰Â²      1  Zâ‚„â‚‰Â²â¸\n\njulia> inv(m)*m\n4Ã—4 Matrix{FFE{7}}:\n 1  0  0  0\n 0  1  0  0\n 0  0  1  0\n 0  0  0  1\n\n\n\n\n\n","category":"module"},{"location":"finitefields/#FiniteFields.FFE","page":"Finite fields","title":"FiniteFields.FFE","text":"FFE{p} is the type of the elements of a finite field of characteristic p.\n\n\n\n\n\n","category":"type"},{"location":"finitefields/#FiniteFields.FFE-Tuple{Integer}","page":"Finite fields","title":"FiniteFields.FFE","text":"FFE{p}(i)  for i an integer or a fraction with denominator prime to p returns the reduction mod p of i, an element of the prime field ð”½â‚š.\n\n\n\n\n\n","category":"method"},{"location":"finitefields/#FiniteFields.GF","page":"Finite fields","title":"FiniteFields.GF","text":"GF(q) the finite field with q elements\n\n\n\n\n\n","category":"type"},{"location":"finitefields/#FiniteFields.Z-Tuple{Any}","page":"Finite fields","title":"FiniteFields.Z","text":"Z(p^d)\n\nreturns  a  generator  of  the  multiplicative  group  of  the finite field ð”½_{páµˆ},  where  Â Â p  must  be  prime  and páµˆ smaller than 2Â¹âµ. This multiplicative  group  is  cyclic  thus  Z(páµˆ)áµƒ  runs  over it for a in 0:páµˆ-1.  The zero  of the  field is  0*Z(p) (the  same as 0*Z(páµˆ); we automatically lower an element to the smallest field which contains it).\n\nThe  various generators returned by Z for finite fields of characteristic p  are compatible. That  is, if the  field ð”½_{pâ¿} is  a subfield of the field ð”½_{páµ}, that is, n divides m, then Z(pâ¿)=Z(páµ)^div(páµ-1,pâ¿-1).  This is  achieved by  choosing Z(p) as the smallest  primitive root  modulo p  and Z(pâ¿)  as a  root of the n-th Conway polynomial of characteristic p. Those polynomials where defined by J.H.~Conway and computed by R.A.~Parker.\n\njulia> z=Z(16)\nFFE{2}: Zâ‚â‚†\n\njulia> z^5\nFFE{2}: Zâ‚„\n\n\n\n\n\n","category":"method"},{"location":"#package-FiniteFields","page":"package FiniteFields","title":"package FiniteFields","text":"This package implements finite fields (FiniteFields), elements of finite fields, and modular numbers (Modulo). \n\nLike  GAP3, we only implement finite fields of order less than 2^16. On the other  hand, Modulo implements modular  arithmetic without restriction on the modulus (the modulus can be a BigInt).\n\nThe module Modulo could be an independent package on its own.","category":"section"}]
}
